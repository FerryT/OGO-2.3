    \section{Gedetailleerde klassenbeschrijving}
    \label{app:klassenbeschrijving}
    We zullen hier de verschillende componenten verder uitdiepen aan de hand van een klassediagram. Het klassediagram bespreken we \emph{top-down}. Het klassediagram zelf is toegevoegd in appendix \ref{app:klassendiagram}. Een aantal basisklassen, zoals $Point2d, Point3d$ en $Vector3d$, zijn hierin voor de overzichtelijkheid niet aangegeven. We maken bovendien de afspraak dat de types $Percentage/Power/Time/Duration$ vrij kunnen worden gebruikt. Deze kunnen bijvoorbeeld \emph{Reals} of \emph{Integers} zijn, afhankelijk van de implementatie. We zijn nu klaar om de gebruikte interfaces te bespreken.

    \subsection{Interfaces}
    Er zijn twee interfaces in het klassendiagram: de zogenaamde $Object$ interface en $BoundingObject$ interface. We geven het implementeren van een interface aan door $\langle\langle$ interface naam $\rangle \rangle$ voor de naam van de klasse, die de interface implementeert.  De klasse Object bevat een aantal standaard attributen om de conversie tussen globale en lokale co\"ordinaten te bewerkstelligen. Dit zijn $origin, yaw, patch$ en $roll$. Hier zijn de hoeken yaw, pitch en roll in graden tussen 0 en 360. 0 is in dit geval inclusief, 360 is exclusief.

    Bovendien bevat Object nog het attribuut $children$, dit is een array van Objects. De reden hiervoor is dat dit hi\"erarchisch modelleren mogelijk maakt. Vervolgens bevat Object nog een aantal methoden: $draw, render, prerender$ en $postrender$. De prerender methode zorgt voor de transformatie van globale co\"ordinaten naar lokale co\"ordinaten. De postrender methode zorgt voor de transformatie van lokale co\"ordinaten naar globale co\"ordinaten.

    De draw methode zorgt voor het tekenen zelf. Deze methode is natuurlijk abstract gemaakt. De render methode combineert alle voorgaande methoden: het roept eerst prerender aan. Vervolgens wordt draw aangeroepen. Daarna wordt ook de draw functie van de Objects in de children array aangeroepen. Als laatste wordt nog postrender aangeroepen.

    De interface BoundingObject is een subklasse van Object. De aard van deze type objecten is zodanig dat ze begrensd zijn. Hier hoort dus een corresponderende \emph{bounding box} bij. De bounding box staat in het attribuut bBox van het type BoundingBox. Ook in dit geval geldt dat de klasse BoundingBox niet in het klassendiagram is opgenomen voor de overzichtelijkheid.

    De bounding box is niet alleen handig voor het tekenen. Het is namelijk ook mogelijk met deze bounding box te testen voor \emph{collisions}. Hier wordt getest of er een collision plaatsvindt van het object met de lijn gegeven door het startpunt origin en met richting direction. Het object zelf of een van de children wordt teruggeven in het geval van een collision. Als er geen collision is, dan zullen we \emph{null} teruggeven. Dit kan bijvoorbeeld gebruikt worden bij het schieten.

    \subsection{Model van de sc\`ene}
    \label{sec:model}
    We zijn nu klaar om de klassen, die worden gebruikt om de sc\`ene te modelleren, te bespreken.  Al deze klassen implementeren de interface BoundedObject. Merk op dat de klasse Object dus niet gebruikt wordt, behalve dat BoundedObject een subklasse hiervan is. Deze klasse kan echter nuttig zijn voor verdere uitbreiding van het spel. We beginnen met de $World$ klasse. Deze bevat een attribuut $homePlayer$ van het type $Player$. Dit attribuut wordt gebruikt om de speler zelf te identificeren.

    De $walkHomePlayer$ wordt gebruikt door de speler om rond te lopen door de wereld. Er wordt dan periodiek een bericht naar alle andere spelers gestuurd om dit door te geven. Verder wordt de $walk$ functie van Player aangeroepen, deze functie wordt verderop nog besproken. De $yesno$ boolean wordt gebruikt om aan te geven of de speler moet lopen of stoppen met lopen. De $shootHomePlayer$ heeft een vergelijkbare interpretatie.

    De $buildBuilding$ wordt gebruikt door de speler om een nieuw gebouw neer te zetten. Hiervoor moet natuurlijk een punt worden aangegeven op de grond en het gewenste gebouw. Het gewenste gebouw is dan van het type $Building$. Als laatste is er nog de functie $pickup$. Deze wordt gebruikt als een speler een object, zoals een muntje, opraapt. Merk op dat dit niet noodzakelijk de speler zelf hoeft te zijn. Opraapbare objecten zijn van het type $Droppable$.

    \subsubsection{Het terrein}
    $World$ heeft een $Terrain$, die het terrein van de sc\`ene voorstelt. Het terrein wordt gemodelleerd door een grid. De methode $groundCollision$ wordt gebruikt bij het bouwen van een gebouw. In deze methode wordt berekend welke cel van de grid is aangeklikt. Merk op dat de cellen van de grid worden aangeklikt met behulp van het vizier en dat het vizier altijd in de huidige kijkrichting staat. Voor groundCollision kan dus de huidige locatie en kijkrichting worden gebruikt.

    De methode $getHeight$ geeft de hoogte van het terrein voor een zekere cel terug. Op dit moment is ons terrein in principe nog vlak, maar dit willen we later nog uitbreiden. Als we het terrein hoogte willen geven, is een mogelijke optie om dit in de grid op te slaan. Aangezien het terrein nu nog vlak is, is dit nog niet opgenomen in het klassendiagram: hiervoor is slechts een simpele en kleine uitbreiding nodig.

    Terrain heeft een array van Droppables en een matrix van $Structures$. Droppable stelt een opraapbaar object voor: dat is nu alleen nog een muntje. Een opraapbaar object heeft een zekere waarde. Bovendien zal een opraapbaar object na een zekere tijd verdwijnen, hiervoor is het attribuut $dieTime$ van het type $Time$. Als laatste is er nog de methode $onPickup$. Deze methode werkt de staat van World bij na de actie die is veroorzaakt door het oppakken van een Droppable. Dus in het geval van een muntje wordt de hoeveelheid goud van het team verhoogd.

    De klasse Structure is abstract: de klassen Mine en Building zijn de subklassen. In de klasse Mine wordt opgeslagen hoeveel inkomen deze mijn genereert in een zekere periode. Deze periode is vast voor alle mijnen. Hiervoor kunnen we dus een constante defini\"eren. De klasse Building is ook weer abstract. Een Building heeft altijd \'e\'en corresponderend team. Het heeft de attributen $cost, income, buildTime, buildDuration, attackPower$ en $health$.

    Het attribuut $cost$ staat voor de totale kosten van het gebouw. $Income$ representeert het inkomen dat het gebouw genereert. Ook hier geldt dat de tijdseenheid vast is. $BuildTime$ representeert het moment waarop de speler de opdracht heeft gegeven het gebouw neer te zetten, $BuildDuration$ vertelt hoelang het bouwen duurt. Dit wordt gebruikt door de animatie van het gebouw. Het wordt verder gebruikt om te bepalen wanneer het neerzetten van het gebouw voltooid is.

    $AttackPower$ geeft aan hoe ernstig het harnas wordt beschadigd, als het gebouw een speler neerschiet. $Health$ geeft de sterkte van het gebouw aan: als de health nul wordt, gaat het gebouw kapot. We merken op dat de attributen $income$ en attackPower geen betekenis hebben voor alle gebouwen. Zo heeft attackPower geen betekenis voor de resourceMine. Als dit het geval is, zal altijd de waarde 0 moeten worden gekozen voor dit attribuut.

    De klasse $ResourceMine, DefenseTower$ en $HQ$ zijn subklassen van $Building$. Een ResourceMine is het gebouw dat over een $Mine$ kan worden geplaatst. Mine staat dus voor de delfplaats en ResourceMine voor de mijn. Een Mine hoeft dus in principe niet van een team te zijn, terwijl een ResourceMine dat altijd zal zijn.

    \subsubsection{De speler en teams}
    World heeft in principe twee $Teams$, deze klasse representeert de verschillende teams. Later kunnen we dit nog uitbreiden naar meer dan twee teams. Elk team heeft een zekere hoeveelheid goud in de kas. Dit wordt opgeslagen in het attribuut resources. Bovendien heeft Team een array van $Players$. Hierin staan natuurlijk de spelers van dat team.

    De klasse Player modelleert een speler in het spel. In het attribuut $health$ wordt de sterkte van het harnas opgeslagen. Het attribuut $lastShoot$ representeert het laatste moment, waarop de speler heeft geschoten. Hierdoor kunnen we het spel uitbreiden, zodat de speler pas weer kan schieten na een zekere \emph{cooldown} periode. De methode $fireLaser$ verzorgt de animatie bij het schieten. Hiervoor wordt de klasse $Laserbeam$ gebruikt: deze klasse heeft een $fireTime$ en $fireDuration$. De fireTime is het moment van vuren. De fireDuration bepaalt dan hoe lang de animatie van het schot duurt. De methode $walk$ in Player zorgt voor de animatie als de speler loopt. Het $connectie$ attribuut maakt het mogelijk voor de $communicator$ klasse om de bijbehorende connectie van een speler op te kunnen vragen.

    \subsubsection{De camera}
    Als laatste heeft de World nog een $Camera$. We laten het nog open voor de implementatie welke attributen worden gebruikt om de camera te representeren. De klasse $Camera$ is een abstracte klasse. Een implementatie van $Camera$ heeft dus de verplichting dat een speler vanuit het juiste punt in de juiste richting kijkt. In principe implementeren wij camera alleen door de klasse PlayerCamera: deze camera bekijkt de wereld vanuit een derde persoonsperspectief. Andere implementaties zijn later nog mogelijk.

    \subsection{Statische objecten}
    Er is nog \'e\'en cruciaal statisch object voor de implementatie van het spel, waarvan de functies door alle andere klassen kunnen worden gebruikt. Dit is de klasse $Communicator$, die de communicatie met andere spelers verzorgt. Een uitgebreide beschrijving van het protocol begint bij \protoref. Met een boolean in deze klasse wordt aangegeven of dit proces de token heeft. Verder wordt opgeslagen wanneer de token voor het laatst is ontvangen. Hiervoor gebruiken we het type Date, die de huidige tijd representeert.

    De klasse Communicator maakt gebruik van de klasse $Message$. De klasse Message representeert het bericht dat moet worden verzonden. Het heeft een attribuut type, die het soort bericht aangeeft. Dit attribuut is van het type $MessageType$, dat voor de overzichtelijkheid is weggelaten uit het klassediagram. MessageType is immers een simpele enumeratie.

    Verder heeft Message nog een boolean $requiresToken$, die aangeeft of de token vereist is om dit soort bericht te mogen versturen. De token wordt gebruikt voor mutual exclusion. Als laatste heeft het message nog een array van argumenten. Het type $Argument$ hangt af van de implementatie, hiervoor kan bijvoorbeeld string of array van bytes worden gekozen. Verder zijn er nog de methoden $addInteger, addReal, addString, addIntegers$ en $addReals$. Deze methoden voegen de type in de naam van de methode toe aan het bericht.

    De methode $broadcastMessage$ stuurt een $message$ naar elke speler die deelneemt aan het spel. Als het bericht een token nodig heeft ($requiresToken = True$) dan wordt het bericht alleen verstuurd als Communicator ook het token heeft ($hasToken = True$). In het geval dat het bericht geen token nodig heeft, wordt het bericht meteen verstuurd. Als het bericht een token nodig heeft en de communicator heeft geen token, dan wordt het bericht niet verstuurd. Dan retourneert de methode ook false: later kan nog een keer worden geprobeerd. In het geval dat het bericht wel wordt verstuurd, dan retourneert de methode true.

    Door middel van de methode $lockToken$ kan men afdwingen dat de token niet meer vrijgegeven wordt totdat $unlockToken$ wordt aangeroepen. De methode heeft \'e\'en parameter $BlockingWait$. Deze parameter geeft aan of de functie moet wachten totdat de communicator de token heeft of direct moet stoppen als de communicator de token niet heeft. Als de communicator niet kan locken omdat de token er nog niet is, retourneert de methode $false$. In elk ander geval wordt $true$ geretourneerd.

    De methode $broadcastTeamMessage$ doet hetzelfde als $broadcastMessage$ behalve dat deze alleen berichten verstuurd naar spelers die in het team $t$ zitten.